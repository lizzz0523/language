为了更深入的了解tornado实现异步io的原理，花了点时间来看ioloop的源代码，其实可以说只要看懂了ioloop和iostream这两个包，基本对tornado的异步io原理就会有一个不错的了解，之后我也会有一篇关于iostream的源码解读文章。

要了解ioloop，我们不得不说一个老生常谈的话题，就是关于在unix上进行网络编程时会遇到的四个模式，阻塞、非阻塞、同步、异步。所以首先我们来说明以下这四种模式分别是什么，他们之间有什么联系和区别。

阻塞和非阻塞，主要是关于进程在调用方法后的不同状态
阻塞：进程在调用方法后，系统就会把该进程挂起，直到系统得到调用的结构后，才重新唤醒该进程
非阻塞：进程在调用方法后，系统会立即返回，而调用的结果是通过状态或者通知等形式获得

而同步和异步，则是关于进程在调用方法后，获取结果的不同方式
同步：进程在调用方法后，需要一直等待调用结果，在得到调用结果后，才能执行下一步的逻辑
异步：进程在调用方法后，不需要等待调用结果，马上可以执行下一步逻辑，调用结构则是通过回调的形式得到

```python
    # 阻塞，同步
    result = read(fd)
    print result
    print 'end'

    # 非阻塞，同步
    while True:
        if result = read(fd):
            break;

    print result
    print 'end'

    # 非阻塞，异步
    read(fd, callback = lambda result: print result)
    print 'end'
```

正常来说，阻塞调用对于系统来说是最合理的，因为当结果还没有准备好时，系统先让进程挂起，这样能最大限度的节省cpu，但这样做对io来说却是十分糟糕的，同一个进程，一次只能处理一个io，对于高并发的web应用来说，则需要通过多进程或者是多线程的方式来完成，系统开销十分大。

为了解决这个问题，提高阻塞调用的io效率，需要引入一个叫io多路复用的东西，说白了就是一个代理中介，在这个代理上可以同时挂载多个io，一旦某个io有数据返回，则唤醒应用进程，这样即使是调用是阻塞的，但由于每个io是独立处理的，一旦某个io返回数据，应用进程就可以触发之前注册的与该io相对应的回调函数，达到了类似异步的效果。在linux上，这样的代理有几种，分别是select，poll，epoll，kqueue...，他们各有优缺点，其中epoll，kqueue的性能是最好的，能轻松面对c10k问题

总结一下：

<img src="https://github.com/lizzz0523/language/blob/master/python/io.png?raw=true" width="479" height="99" />
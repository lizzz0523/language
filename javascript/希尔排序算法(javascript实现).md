### 希尔排序

希尔排序其本质也是插入排序，然而插入排序由于每次只能对相邻的两个数字进行比较，因此需要较多的交换次数，才能完成排序。而希尔排序则通过改变比较的步长，把比较的范围扩大，使得整个数组快速的进入有序的状态，从而加快排序的速度。

例如我们有以下数组
```javascript
    var arr = [3, 1, 2, 5, 6];
```
首先我们确定一下比较的步长，从二分之一的数组长度开始，也就是5/2=2，然后确定比较的起始位置，这里从0开始，于是就得出这样一个子数组
```javascript
    var arr1 = [3, 2, 6];
```
我们对这个子数组进行插入排序，得到结果
```javascript
    arr1 = [2, 3, 6];
```
也就是
```javascript
    arr = [2, 1, 3, 5, 6];
```
然后我们以1作为起始位置，于是得到了另外一个子数组
```javascript
    var arr2 = [1, 5];
```
然后对这个子数组进行插入排序，得到
```javascript
    arr2 = [1, 5];
```
也就是
```javascript
    arr = [2, 1, 3, 5, 6];
```
现在我们改变比较的步长，为原来的二分之一，即2/2=1，起始位置也是从0开始，起始也就是原数组
```javascript
    arr3 = [2, 1, 3, 5, 6];
```
对该数组进行插入排序，由于现在这个数组已经基本有序了，因此交换的次数就会减少，在我们的例子中，只需要进行一次交换即可，也就是把1和2交换
```javascript
    arr3 = [1, 2, 3, 5, 6];
```
这时已经完成了对数组的排序，具体的代码如下
```javascript
    function shellSort(arr) {
        // 首先我们定制出比较的步长，由二分之一的数组长度开始，逐步缩小步长，当步长缩小到1时，就降级为插入排序了
        for (var step = arr.length / 2 >> 0; step > 0; step = step / 2 >> 0) {
            // 确定步长后，再确定比较的起始的位置，这里是从0开始
            for (var init = 0; init < step; init++) {

                // 接下来的步骤就和插入排序是一致的，插入排序中i是从1开始的，这里i是从起始位置+步长开始的
                for (var i = init + step; i <= arr.length - 1; i += step) {
                    var t = arr[i];

                    for (var j = i; j >= step; j -= step) {
                        if (arr[j - step] > t) {
                            arr[j] = arr[j - step];
                        }
                    }

                    arr[j] = t;
                }
            }
        }
    }
```
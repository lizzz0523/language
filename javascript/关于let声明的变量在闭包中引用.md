昨天部门内部贴了一道面试题，题目如下
```javascript
    for (let i = 0; i < 5; i++) {
        setTimeout(function () {
            console.log(i);
        }, i * 1000);
    }

    console.log(i)
```
问输出的结果是什么，刚开始没有考虑太多，就知道`let`是块作用域，因此在`for`后面引用`i`，应该是`undefined`，然后按照以往的经验，在`setTimeout`中是以闭包的形式引用`i`，因此在输出的时候，这个`i`应该等于`for`循环结束后的值，也就是`5`。于是自信满满的回复说：
```javascript
    undefined
    5
    5
    5
    5
    5
```
然而悲剧了，今天回到公司，尝试验证一下自己的答案，md，全错了，真正输出的是
```javascript
    Uncaught ReferenceError
    0
    1
    2
    3
    4
```
老司机撞车了，马上百度了一下，找到了阮老师的一篇关于`let`关键字的说明[let和const命令](http://es6.ruanyifeng.com/#doc/let)，终于阔然开朗。

这里要解答两个问题，一个是为啥第一次输出的不是`undefined`，而是抛出异常，这里主要是以前我们使用`var`声明变量是的一种错觉，由于`var`声明的变量会出现声明提升的问题，也就是
```javascript
    console.log(i);
    for (var i = 0; i < 5; i++) {}
```
实际上是
```javascript
    var i;
    console.log(i);
    for (i = 0; i < 5; i++) {}
```
这时变量`i`实际时已经声明，但并没有赋值，所以才会出现的`undefined`。而在使用`let`关键字声明变量时，由于是块作用域，并且不存在这种声明提升的问题，因此在`for`循环以外，这个`i`变量就是没有声明过，更加不可能赋值过，因此，浏览器就会抛出异常。

第二个问题是，为啥闭包内对`i`的引用会有多个值，这里要说一下`for`循环。表面上看，`for`循环只有一个块，然而实际上，`for`循环在循环体每次执行的时候都会创建一个新的块，也就是每次执行循环体，其块作用域都是不同的，作用域中的变量`i`都是不同的`i`，只是js引擎在每次循环的时候，都会根据上一次循环时变量`i`的值来初始化本次循环变量`i`的值。亦即闭包中引用的`i`，其实是不同作用域下的的变量`i`，导致最后输出的结果也是不一样的。